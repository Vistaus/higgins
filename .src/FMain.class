' Gambas class file

Public Struct rItem
  Priority As Integer
  Category As String 'app,locate,calculate,desktopexec,execute
  Text As String
  SubText As String
  Mexec As String
  'pic As Picture
  happ As DesktopApps
  uri As String
End Struct

Public locatep As Process
Public results_file As String = Temp()
Public results_list As New RItem[]
Public rSize As Integer

'how many characters needs to be entered to start the following searches
Public Const min_char_app As Integer = 2
Public Const min_char_execute As Integer = 2
Public Const min_char_app_by_desc As Integer = 3
Public Const min_char_calculate As Integer = 2
Public Const min_char_locate As Integer = 3

'no effect by now, may come handy to sort the results (?)
Public Const calculate_priority As Integer = 100
Public Const app_priority As Integer = 90
Public Const execute_priority As Integer = 80
Public Const DesktopExec_priority As Integer = 70
Public Const locate_priority As Integer = 60

Public Const appname As String = "higgins"
Public Socket_File As String = Settings.defaultdir & "/" & appname & ".socket"
Public Lock_File As String = Settings.defaultdir & "/" & appname & ".lock"

Public firstrun As Boolean = True

'Public Socket_File As String = "/tmp/socket"
'Public Lock_File As String = "/tmp/lock"

Public Sub resize_form()
  FMain.h = TextBox1.h + (Desktop.scale * 3)

End

Public Sub TextBox1_Change()
  Dim previous_search As String
  Dim current_search As String
  Try current_search = TextBox1.text 
  If Error Then Return
  Wait 0.01
  If current_search = "" Then 
    resize_form()
    reinit()
    Return
  Endif
  
  kill_locate()
  
  DesktopApps.stop_get = True
  While DesktopApps.getting
    Wait
  Wend
  DesktopApps.stop_get = False
  
  Try previous_search = TextBox1.text
  If Error Then Return
  Wait 0.3

  Try current_search = TextBox1.text 
  If Error Then Return
  If previous_search <> current_search Then Return

  search(current_search)
End

Public Sub initgrid()
  ResultGrid.Rows.count = 0
  ResultGrid.columns.count = 1
  ResultGrid.mode = Select.Single
  ResultGrid.Show()
End

Public Sub reinit()
  Dim padding As Integer
  results_list.Clear()
  initgrid()
  MyDesktop.init()
  kill_locate()
  padding = (Desktop.scale * 2)
  resultgrid.Rows.h = resultgrid.Font.RichTextHeight("|j<br>|j") + padding
  rSize = ResultGrid.Rows.H - padding
End

Public Sub kill_locate()
    Dim running As String
    If locatep <> Null Then
      While Exist("/proc/" & locatep.handle)
        'Debug "kill  locate"
        Try locatep.drop
        Try locatep.close
        Try locatep.kill
        Wait
      Wend
      'Until (locatep.state <> locatep.Running) 
    Endif
End



Public Sub search(term As String)
  Dim results As String
  reinit()
  FMain.h = TextBox1.h + (Desktop.scale * 3) + resultgrid.h
  FMain.mouse = Mouse.wait

  Select Left(term)
    Case "="
      Calculate(Right(term, -1))
    Case Else
      resultgrid.tag = "locate"

      'search for apps
      find_apps(term)
      
      'search for apps by description
      find_apps_by_desc(term)

      'search for executables
      find_executables(term)

      'search for files
      locate(term)
  End Select
  FMain.mouse = Mouse.Default
End

Public Sub Calculate(term As String)
  Dim result As New RItem
  If String.Len(term) < min_char_calculate Then Return
  Try result.Text = Eval(Term)
  If Error Then Return
  result.Category = "calculate"
  result.Priority = calculate_priority
  resultgrid.Rows.count = 1
  results_list.Add(result)
End


Public Sub find_apps(term As String)
  Dim happ As New DesktopApps
  Dim app As String
  Dim result As RItem
  If String.Len(term) < min_char_app Then Return

  For Each app In DesktopApps
    If InStr(Lower(app), Lower(term)) Then
      happ = DesktopApps[app]
      result = New RItem
      result.category = "app"
      result.Priority = app_priority
      result.Text = happ.name
      result.subtext = happ.comment
      result.mExec = happ.Exec_R_noargs
      result.uri = happ.file_path
      result.happ = happ
      results_list.Add(result)
      ResultGrid.Rows.count += 1
      Wait
    Endif
  Next
End

Public Sub find_apps_by_desc(term As String)
  Dim happ As New DesktopApps
  Dim app As String
  Dim ismatched As Boolean = False
  Dim result As RItem

  If String.Len(term) < min_char_app_by_desc Then Return
  For Each app In DesktopApps
    happ = DesktopApps[app]
    If happ = Null Then Return
    ismatched = InStr(Lower(happ._$Comment), Lower(term)) > 0 
    ismatched = ismatched Or InStr(Lower(happ._$Category), Lower(term)) > 0 
    ismatched = ismatched Or InStr(Lower(happ._$Keywords), Lower(term)) > 0 
    If ismatched Then
      result = New RItem
      result.category = "app"
      result.Priority = app_priority
      result.Text = happ.name
      result.subtext = happ.comment
      result.mExec = happ.Exec_R_noargs
      result.uri = happ.file_path
      result.happ = happ
      results_list.Add(result)
      ResultGrid.Rows.count += 1
    Endif
  Next
End

Public Function Which(exe As String) As String
  Dim exefound As String
  Shell "which " & exe To exefound
  Return Trim(exefound)
End

Public Sub find_executables(term As String)
  Dim exe, exe_found As String 
  Dim result As RItem
  Try exe = Split(term, " ", "", True)[0]
  If exe = "" Then Return
  
  exe_found = Which(exe)
  If exe_found = "" Then Return
  result = New RItem
  result.Category = "execute"
  result.Mexec = term
  result.Priority = execute_priority
  result.Text = "Run " & term
  result.SubText = "From " & File.Dir(exe_found)
  result.uri = exe_found
  results_list.Add(result)
  ResultGrid.Rows.count += 1
  
  result = New RItem
  result.Category = "execute_terminal"
  result.Mexec = term
  result.Priority = execute_priority
  result.Text = "Run " & term & " in the terminal emulator"
  result.SubText = "From " & File.Dir(exe_found) 
  result.uri = exe_found
  results_list.Add(result)
  ResultGrid.Rows.count += 1
  
End


Public Sub locate(term As String)
Dim tmp As String
  If String.Len(term) < min_char_locate Then Return
  'locatep = Shell "nice -n -19 locate -l 1000 -i " & "'" & term & "'" For Input As "locatep"
  locatep = Shell "nice -n -19 locate -l 100 -i " & "'*" & term & "*'" For Input As "locatep"
  locatep.Blocking = True
  locatep.tag = term
  Debug "locate " & "'" & term & "'" 
End


Public Sub locatep_read()
  Dim results, result As String
  Dim rResult As RItem
  Dim is_desktop_exec As Boolean = False
  Dim t As String
  Dim stream_ok As Boolean 

  stream_ok = False
  Try stream_ok = Not Eof(locatep)
  If Not stream_ok Then Return

  Try Line Input #locatep, result
  If Error Then Return
  If (result = "") Or (locatep.tag <> TextBox1.text) Then 
    Wait 
    Return
  Endif
  If Not Exist(result, True) Then Return
  rResult = New RItem

  If result Ends ".desktop" Then 
    MyDesktop.init()
    MyDesktop.parse(result)
    If MyDesktop.dExec <> "" Then is_desktop_exec = True
  Endif

  If is_desktop_exec Then
    rResult.Category = "desktopexec"
    rResult.Priority = DesktopExec_priority
      Else
    rResult.Category = "locate"
    rResult.Priority = locate_priority
  Endif

  rResult.mExec = result
  rResult.uri = result
  
  If Stat(result, True).type = gb.directory Then 
    rResult.Text = File.Name(result) & "/"
      Else
    rResult.Text = File.Name(result)
  Endif
  
  rResult.SubText = File.Dir(result)

  results_list.Add(rResult)
  ResultGrid.Rows.count += 1

End



Public Sub ResultGrid_Data(Row As Integer, Column As Integer)
  Dim img As Image
  Dim t As String
  Dim i As Integer
  Dim rcResult As New RItem
  If results_list.count = 0 Then Return
  rcResult = results_list[Row]
  If resultgrid.current = Null Then resultgrid.Rows[0].Selected = True

  'two lines:
  resultgrid.data.RichText = "<b>" & rcResult.text & "</b>"
  If rcResult.subtext <> "" Then 
    resultgrid.data.RichText &= "<br><font size=-1>" & rcResult.subtext & "</font>"
  Endif

  'find pic
  Select Case rcResult.Category  'app,locate,calculate,desktopexec
    Case "app"
      resultgrid.Data.Picture = rcResult.happ.GetIcon(rSize).Picture
    Case "execute"
      resultgrid.Data.Picture = Picture["icon:/" & rSize & "/exec"]
    Case "execute_terminal"
      resultgrid.Data.Picture = Picture["icon:/" & rSize & "/terminal"]
    Case "desktopexec"
      MyDesktop.parse(rcResult.uri)
      resultgrid.Data.Picture = MyDesktop.GetIcon(MyDesktop.dIconName, rsize).picture 
      'DesktopMime.FromFile(rcResult.mExec).GetIcon(rSize).Picture
    Case "locate"
      If rcResult.text Ends "/" Then
        resultgrid.Data.Picture = Picture["icon:/" & rSize & "/directory"]
          Else
        resultgrid.Data.Picture = DesktopMime.FromFile(rcResult.uri).GetIcon(rSize).Picture
      Endif
    Case "calculate"
      resultgrid.Data.Picture = Picture["icon:/" & rSize & "/calculator"]
  End Select
  If resultgrid.Data.picture = Null Then
    resultgrid.Data.Picture = Picture["icon:/" & rSize & "/file"]
  Endif
  
End

Public Sub start_item(i As Integer)
  Dim rcResult As New RItem
  Dim df As Desktopfile
  Dim xdg_terminal As String
  Dim cmdline As String
  
  rcResult = results_list[i]
  Select Case rcResult.Category 'app,locate,calculate,desktopexec

    Case "locate"
      Desktop.Open(rcResult.mExec)

    Case "execute_terminal"
      xdg_terminal = Temp
      Copy "xdg-terminal.sh" To xdg_terminal
      Chmod xdg_terminal To "rwxr-x---" 
      Shell xdg_terminal & " \"" & "sh -c ' " & rcResult.mExec & "; echo; echo  Press enter to exit ; read ' \""
    Case "execute"
      Shell rcResult.mExec

    Case "app"
      Shell rcResult.mExec

    Case "desktopexec"
      Shell rcResult.mExec
  End Select
End


Public Sub ResultGrid_activate()
  start_item(resultgrid.row)
  TimerClose.Trigger
End

Public Sub TextBox1_KeyPress()
  Select Key.Code
    Case Key.down
      ResultGrid.SetFocus()
      Try resultgrid.Rows[1].Selected = True
    Case Key.PgDown
      ResultGrid.SetFocus()
      Try resultgrid.Rows[1].Selected = True
    Case Key.enter
      Try start_item(0)
      If Not Error Then timerClose.Trigger()
    Case Key.Return
      Try start_item(0)
      If Not Error Then timerClose.Trigger()
  End Select
End


Public Sub ResultGrid_KeyPress()
  Select Key.Code
    Case Key.Enter
      start_item(resultgrid.row)
      TimerClose.trigger
    Case Key.Return
      start_item(resultgrid.row)
      TimerClose.trigger
    Case Key.up
      If ResultGrid.Rows[0].Selected Then TextBox1.SetFocus()
    Case Key.PageUp
      If ResultGrid.Rows[0].Selected Then TextBox1.SetFocus()
  End Select
End


Public Sub MenuOpenFolder_Click()
  Try Desktop.Open(File.Dir(results_list[resultgrid.row].uri))
  TimerClose.Trigger
End

Public Sub MenuOpenFile_Click()
  Try Desktop.Open(resultgrid.Current.text)
  TimerClose.Trigger
End

Public Sub MenuCopy_Click()
  Try Clipboard.Copy(results_list[ResultGrid.row].uri)
End


Private Function Screenbypos(x As Integer, y As Integer) As Screen
  Dim s As Screen
  For Each s In Screens
    If (x >= s.x) And x <= (s.x + s.W) Then
      If (y >= s.y) And y <= (s.y + s.h) Then
        Return s
      Endif
    Endif
  Next
  
  'no screen found !? repeat with more tolerance:
  For Each s In Screens
    If (x + 50 >= s.x) And x <= (s.x + s.W + 50) Then
      If (y + 50 >= s.y) And y <= (s.y + s.h + 50) Then
        Return s
      Endif
    Endif
  Next

  'still no screen found? return the first.
  Debug "Couldn 't get the matching screen (!)"
  Return Screens[0]
End


Public Function Relative_window_geom(o As Window) As Integer[]
  'get the object position relative to the screen is on
  Dim rx, ry, ox, oy As Integer
  Dim cs As Screen
  Dim out As New Integer[]
  cs = Screenbypos(o.x, o.y)
  ox = cs.X 'offset
  oy = cs.Y 'offset
  rx = o.x - ox
  ry = o.y - oy
  out.Add(rx)
  out.Add(ry)
  out.Add(o.w)
  out.Add(o.h)
  Return out
End


'======================================== START SOCKET FUNCTIONS ========================================

              Public My_listening_socket As ServerSocket
              
              
              Public hLock As Stream
              
              Public Sub socket_init()
                'TRY TO get a LOCK file:
                Try hLock = Lock Lock_File
                If Error Then 'alreadyrunning
                  Debug "another instance already running"
                  show_other_instance()
                  Quit
                Endif
                'start to listen for remote commands, one connection is ok.
                My_listening_socket = New ServerSocket As "My_listening_socket"
                My_listening_socket.type = Net.Unix
                My_listening_socket.path = Socket_File
                My_listening_socket.Listen(1)
              End
              
              Public MyCSock As Socket
              Public Sub show_other_instance()
                Dim sBuf As String
                MyCSock = New Socket
                MyCSock.path = Socket_File
                MyCSock.Port = Net.Local
                MyCSock.Connect()
                While (MyCSock.Status <> 7) And (MyCSock.Status > 0)
                  Wait 0.1
                Wend
                If MyCSock.Status = 7 Then
                  sBuf = "show\n"
                  Write #MyCSock, sBuf, Len(sBuf)
                  Close #MycSock
              
                Endif
              End
              
              Public Host As Object
              Public Sub My_listening_socket_connection(RemoteHostIP As String)
                'just accept on localhost.
                host = My_listening_socket.Accept()
              End
              
              Public Sub socket_Read()
                Dim command As String = ""
                'Stop
                Line Input #Last, command
                If command = "show" Then
                  Repeat
                    fmain.visible = True
                    Wait
                  Until fmain.visible = True
                  Debug fmain.visible
                Endif
                My_listening_socket.close
                My_listening_socket.Listen(1)
              End

'-- END SOCKET FUNCTIONS ---------------------------------------------------------------------

Public TrayIcon2 As Trayicon 'fixme trayicon
Public Sub InitTrayIcon()
  'fixme trayicon

  Dim SystemTray As Boolean = True
  Try SystemTray = desktop.HasSystemTray
  If Error Then
    Debug "Couldn't check if your desktop has a system tray, assuming it has"
  Endif

  If Not SystemTray Then Return
  Try TrayIcon2 = New Trayicon 
  If Error Then Debug "Cannot Init Trayicon"
  TrayIcon2.Picture = Picture["appicon.png"]
  TrayIcon2.Visible = True
  object.Attach(TrayIcon2, Me, "TrayIcon2")
  TrayIcon2.PopupMenu = "TrayMenu"
  If Error Then Debug "Cannot Init Trayicon"
End

Public Sub TrayIcon2_click()
  fmain.Show()
End




Public Sub Form_Open()
  If Not firstrun Then Return
  load_geometry()
  socket_init()
  InitTrayIcon()
  resize_form()
  firstrun = False
End

Public Sub load_geometry()
  Dim s As Screen
  Dim rx, ry, w, h As Integer
  s = Screenbypos(Mouse.ScreenX, Mouse.ScreenY)
  rx = Settings["win_rx", 0] 
  ry = Settings["win_ry", 0] 
  w = Settings["win_w", (s.w Div 2)] 
  ' h = Settings["win_h", 64] 
  fmain.Move(rx + s.x, ry + s.y, w)
End

Public Sub save_geometry()
  Dim xy_r As Integer[]
  xy_r = Relative_window_geom(fmain)
  Settings["win_rx"] = xy_r[0]
  Settings["win_ry"] = xy_r[1]
  Settings["win_w"] = xy_r[2]
  ' Settings["win_h"] = xy_r[3]
  Settings.Save()
End

Public Sub TimerClose_Timer()
  save_geometry()
  fmain.close

End

Public Sub myQuit()
  Quit
End

Public Sub Form_KeyRelease()
  If Key.code = Key.esc Then Form_Hide()
End

Public Sub Form_Hide()
  If fmain.tag = "minimized" Then Return
  save_geometry()
  fmain.visible = False
  fmain.tag = "minimized"
End

Public Sub Form_Show()
  fmain.visible = True
  fmain.tag = ""
  resize_form()
   Wait
End

Public Sub Form_Close()
  Form_Hide()
End


Public Sub QuitMenuTray_Click()
  myQuit()
End

Public Sub QuitMenu_Click()
  myQuit()
End


Public Sub TextBox1_GotFocus()
  Dim o As Object
  o = findSelectable(TextBox1)
  Wait
  If o <> Null Then 
    o.selectall
  Endif
End


Private Function findSelectable(o As Object) As Object
  Dim c As Integer = 0
  Dim child, selectable As Object
  Try o.selectall
  If Error Then
    Try c = O.children.count
    If c > 0 Then
      For Each child In O.children
        selectable = findSelectable(CHILD)
        If selectable <> Null Then 
          Return selectable
        Endif
      Next
    Endif
      Else
    Return o
  Endif
End

